import { useRef, useEffect, use } from 'react'
import { useGLTF } from '@react-three/drei'
import { useFrame, useThree } from '@react-three/fiber'
import { a } from '@react-spring/three'

/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Author: Conrad Justin (https://sketchfab.com/ConradJustin)
License: SKETCHFAB Standard (https://sketchfab.com/licenses)
Source: https://sketchfab.com/3d-models/baker-and-the-bridge-da3f6e7b85ed44b7aa8bb5571e365abc
Title: Baker and the Bridge
*/

import islandScene from '../baker_and_the_bridge/scene.gltf';

const Island = ({ isRotating, setIsRotating, currentStage, setCurrentStage, currentFocusPoint, setBeeFacingLeft, setRotationDirection,...props }) => {
    const islandRef = useRef()

    const { gl, viewport } = useThree()
    const { nodes, materials } = useGLTF(islandScene)

    const lastX = useRef(0.1)
    const rotationSpeed = useRef(0.1)
    const dampingFactor = 0.85

    const handlePointerDown = (event) => {
        event.stopPropagation()
        event.preventDefault()
        setIsRotating(true)

        const clientX = event.touches ? event.touches[0].clientX : event.clientX;
        lastX.current = clientX
    }

    const handlePointerUp = (event) => {
        event.stopPropagation()
        event.preventDefault()
        setIsRotating(false)
    }

    const handlePointerMove = (event) => {
        event.stopPropagation();
        event.preventDefault();

        if (isRotating) {
            const clientX = event.touches ? event.touches[0].clientX : event.clientX;
            const delta = (clientX - lastX.current) / viewport.width;

            islandRef.current.rotation.y += delta * 0.01 * Math.PI * 0.5;
            rotationSpeed.current = delta * 0.01 * Math.PI;

            const deltaX = clientX - lastX.current;  // calculate actual drag direction
            if (deltaX > 0) {
            setBeeFacingLeft(false); // moving right ➡️ face right
            } else if (deltaX < 0) {
            setBeeFacingLeft(true);  // moving left ⬅️ face left
            }

            setRotationDirection(Math.sign(deltaX)); // NEW: tell Sky the drag direction
            lastX.current = clientX; // update tracker
        }
    }

    const handleKeyDown = (event) => {
        if (event.key === 'ArrowLeft') {
            if (!isRotating) setIsRotating(true);
            islandRef.current.rotation.y += 0.1 * Math.PI;
            setBeeFacingLeft(false);   // Arrow left → bee should face left
            } else if (event.key === 'ArrowRight') {
            if (!isRotating) setIsRotating(true);
            islandRef.current.rotation.y -= 0.1 * Math.PI;
            setBeeFacingLeft(true);  // Arrow right → bee should face right
        }
    }

    const handleKeyUp = (event) => {
        if(event.key === 'ArrowLeft' || event.key === 'ArrowRight') {
            if(isRotating) setIsRotating(false)
        }
    }

    
    useFrame(() => {
        // If not rotating, apply damping to slow down the rotation (smoothly)
        if (!isRotating) {
            // Apply damping factor
            rotationSpeed.current *= dampingFactor;
            
        // Stop rotation when speed is very small
        if (Math.abs(rotationSpeed.current) < 0.001) {
            rotationSpeed.current = 0;
        }
            
            islandRef.current.rotation.y += rotationSpeed.current;
        } else {
            // When rotating, determine the current stage based on island's orientation
        const rotation = islandRef.current.rotation.y;

        if (rotationSpeed.current > 0) {
            setBeeFacingLeft(false);
        } else if (rotationSpeed.current < 0) {
            setBeeFacingLeft(true);
        }
        /**
         * Normalize the rotation value to ensure it stays within the range [0, 2 * Math.PI].
         * The goal is to ensure that the rotation value remains within a specific range to
         * prevent potential issues with very large or negative rotation values.
         *  Here's a step-by-step explanation of what this code does:
         *  1. rotation % (2 * Math.PI) calculates the remainder of the rotation value when divided
         *     by 2 * Math.PI. This essentially wraps the rotation value around once it reaches a
         *     full circle (360 degrees) so that it stays within the range of 0 to 2 * Math.PI.
         *  2. (rotation % (2 * Math.PI)) + 2 * Math.PI adds 2 * Math.PI to the result from step 1.
         *     This is done to ensure that the value remains positive and within the range of
         *     0 to 2 * Math.PI even if it was negative after the modulo operation in step 1.
         *  3. Finally, ((rotation % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI) applies another
         *     modulo operation to the value obtained in step 2. This step guarantees that the value
         *     always stays within the range of 0 to 2 * Math.PI, which is equivalent to a full
         *     circle in radians.
        */
       const normalizedRotation =
       ((rotation % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
       
       // Set the current stage based on the island's orientation
       switch (true) {
           case normalizedRotation >= 5.45 && normalizedRotation <= 5.85:
               setCurrentStage(4);
               break;
               case normalizedRotation >= 0.85 && normalizedRotation <= 1.3:
                   setCurrentStage(3);
                   break;
                   case normalizedRotation >= 2.4 && normalizedRotation <= 2.6:
                       setCurrentStage(2);
                       break;
                       case normalizedRotation >= 4.25 && normalizedRotation <= 4.75:
                           setCurrentStage(1);
                           break;
                           default:
                               setCurrentStage(null);
                            }
                        }
                    })
                    
    useEffect(() => {
        const canvas = gl.domElement

        canvas.addEventListener('pointerdown', handlePointerDown)
        canvas.addEventListener('pointerup', handlePointerUp)
        canvas.addEventListener('pointermove', handlePointerMove)
        document.addEventListener('keydown', handleKeyDown)
        document.addEventListener('keyup', handleKeyUp)

        return () => {
            canvas.removeEventListener('pointerdown', handlePointerDown)
            canvas.removeEventListener('pointerup', handlePointerUp)
            canvas.removeEventListener('pointermove', handlePointerMove)
            document.removeEventListener('keydown', handleKeyDown)
            document.removeEventListener('keyup', handleKeyUp)
        }
    }, [gl, handlePointerDown, handlePointerUp, handlePointerMove, handleKeyDown, handleKeyUp])
                    
    return (
        <a.group ref={islandRef} {...props}>
        <group rotation={[Math.PI / 2, 0, -Math.PI]}>
            <group rotation={[-Math.PI, 0, 0]} scale={0.01}>
            <group rotation={[0, 0, -Math.PI / 2]} scale={100}>
            <mesh
                castShadow
                receiveShadow
                geometry={nodes.characters_STONE_a_0.geometry}
                material={materials.STONE_a}
            />
            <mesh
                castShadow
                receiveShadow
                geometry={nodes.characters_STONE_a_0_1.geometry}
                material={materials.STONE_a}
            />
          </group>
          <group rotation={[0, 0, -Math.PI / 2]} scale={100}>
            <mesh
                castShadow
                receiveShadow
                geometry={nodes.characters007_bush_0.geometry}
                material={materials.bush}
            />
            <mesh
                castShadow
                receiveShadow
                geometry={nodes.characters007_bush_0_1.geometry}
                material={materials.bush}
            />
          </group>
            <mesh
                castShadow
                receiveShadow
                geometry={nodes.characters001_charcters_0.geometry}
                material={materials.charcters}
                rotation={[0, 0, -Math.PI / 2]}
                scale={100}
          />
            <mesh
                castShadow
                receiveShadow
                geometry={nodes.characters002_watermill_0.geometry}
                material={materials.watermill}
                rotation={[0, 0, -Math.PI / 2]}
                scale={100}
            />
            <mesh
                castShadow
                receiveShadow
                geometry={nodes.characters003_terrain_left_0.geometry}
                material={materials.terrain_left}
                rotation={[0, 0, -Math.PI / 2]}
                scale={100}
            />
            <mesh
                castShadow
                receiveShadow
                geometry={nodes.characters004_house_0.geometry}
                material={materials.house}
                rotation={[0, 0, -Math.PI / 2]}
                scale={100}
            />
            <mesh
                castShadow
                receiveShadow
                geometry={nodes.characters005_bridge_0.geometry}
                material={materials.bridge}
                rotation={[0, 0, -Math.PI / 2]}
                scale={100}
            />
            <mesh
                castShadow
                receiveShadow
                geometry={nodes.characters006_tree_0.geometry}
                material={materials.tree}
                rotation={[0, 0, -Math.PI / 2]}
                scale={100}
            />
            <mesh
                castShadow
                receiveShadow
                geometry={nodes.characters008_water_0.geometry}
                material={materials.water}
                rotation={[0, 0, -Math.PI / 2]}
                scale={100}
            />
            <mesh
                castShadow
                receiveShadow
                geometry={nodes.characters009_terrain_right_0.geometry}
                material={materials.terrain_right}
                rotation={[0, 0, -Math.PI / 2]}
                scale={100}
            />
            <mesh
                castShadow
                receiveShadow
                geometry={nodes.characters010_wheat_0.geometry}
                material={materials.wheat}
                rotation={[0, 0, -Math.PI / 2]}
                scale={100}
            />
            </group>
        </group>
    </a.group>
  )
}

export default Island
